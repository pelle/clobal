(ns clobal.importing
  (:require [clojure.xml :as xml]
            [clojure.zip :as zip]
            [clojure.data.csv :as csv]
            [clojure.java.io :as io]
            [slugger.core :as slug]))




(defn convert-xml
  "This is used to convert the raw xml file from iso-codes"
  [file]
  (:content
   (first
    (zip/xml-zip
     (xml/parse (java.io.ByteArrayInputStream. (.getBytes (slurp file))))))))


(defn flat-xml [xml]
  (map :attrs xml))


(defn blank-is-nil [d]
  (if (and d (not= d ""))
    d))

(defn convert-csv [file]
  (let [rows (with-open [in-file (io/reader file)]
                (doall
                  (csv/read-csv in-file)))
        header (map keyword (first rows))]
        (map
          (fn [row] (into {} (map #(vector % (blank-is-nil %2)) header row))) (rest rows))
  ))

(defn assoc-regions
  [m c]
  (assoc m (keyword (:code (:attrs c)))
         (vec (flatten
               (map
                (fn [r]
                  (let [type (keyword (slug/->slug (:type (:attrs r))))]
                    (map #(assoc % :type type
                                 :slug (slug/->slug (:name %))
                                 :code (keyword (:code %)))
                         (flat-xml (:content r)))
                    ))
                (:content c))))))

(defn convert-country-codes
  "read data from country-code project and create a vector of maps"
  []
  (convert-csv "data/country-codes/data/country-codes.csv"))

(defn country-currency
  "Create a map between alpha 2 letter iso country code and 3 letter iso currency code"
  []
  (reduce #(assoc %1 (keyword (%2 :ISO3166-1-Alpha-2)) (if-let [c (%2 :currency_alphabetic_code)]
                                                                    (keyword c))) (convert-country-codes)))

(defn convert-iso3166-2
  ([] (convert-iso3166-2 "data/iso-codes/iso_3166_2/iso_3166_2.xml"))
  ([file]
     (reduce assoc-regions {} (convert-xml file))))

(defn convert-iso3166
  ([] (convert-iso3166 "data/iso-codes/iso_3166/iso_3166.xml"))
  ([file]
     (map #(assoc % :numeric_code (Integer/parseInt (:numeric_code %))
                    :slug (slug/->slug (:name %))
                    :alpha_2_code (keyword (:alpha_2_code %))
                    :alpha_3_code (keyword (:alpha_3_code %)))
          (remove :date_withdrawn (flat-xml (convert-xml file))))))

(defn combine-iso3166
  []
  (let [countries (convert-iso3166)
        currencies (country-currency)]
    (map #(assoc % :currency (currencies (:alpha_2_code %))) countries)))

(defn print-var
  [w name data]
  (.write w ";; Autogenerated\n")
  (clojure.pprint/pprint (seq [`def (symbol name) data]) w)
  (.write w "\n"))



(defn print->ns [name f]
  (with-open [w (clojure.java.io/writer (str "src/clobal/data/" name ".clj"))]
    (.write w (str "(ns clobal.data." name ")\n\n"))
    (f w name)


    ))

(defn country-ns
  []
  (print->ns "countries"
             (fn [w name]
               (let [data (combine-iso3166)]
                 ;; (print-var w name (vec data))
                 (print-var w "countries" (reduce #(assoc % (:alpha_2_code %2) %2) {} data))
                 ;; (print-var w "slug->countries" (group-by :slug data))
                 ))))

(defn regions-ns
  []
  (print->ns "regions"
             (fn [w name]
               (let [data (convert-iso3166-2)]
                 ;; (print-var w name (vec data))
                 (print-var w "regions" data )
                 ;; (print-var w "slug->countries" (group-by :slug data))
                 ))))

(defn currencies-ns
  []
  (print->ns "currencies"
             (fn [w name]
               (let [data (vec (convert-country-codes))]
                 ;; (print-var w name (vec data))
                 (print-var w "currencies" data )
                 ;; (print-var w "slug->countries" (group-by :slug data))
                 ))))

